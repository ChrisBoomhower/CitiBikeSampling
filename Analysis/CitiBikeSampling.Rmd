---
title: "MSDS 6370 Sampling Design"
output:
  html_notebook: default
---

### Load the data

Load necessary libraries

```{r}
require(survey)
require(dplyr)
require(lattice)
```

Pulling in data only if RDS file has not already been created.

```{r}
setwd("../Analysis/Data")
if(!file.exists("popData.rds")){
    pop.data <- NULL
    for(i in 1:length(list.files())){
        data.frag <- read.csv(paste("dataset",i,".csv",sep = ""), header = FALSE)
        pop.data <- rbind(pop.data, data.frag)
    }
    colnames(pop.data) <- c("tripduration",
                            "starttime",
                            "stoptime",
                            "start_station_id",
                            "start_station_name",
                            "start_station_latitude",
                            "start_station_longitude",
                            "end_station_id",
                            "end_station_name",
                            "end_station_latitude",
                            "end_station_longitude",
                            "bikeid",
                            "usertype",
                            "birth year",
                            "gender",
                            "LinearDistance",
                            "DayOfWeek",
                            "TimeOfDay",
                            "HolidayFlag",
                            "PRCP",
                            "SNOW",
                            "TAVE",
                            "TMAX",
                            "TMIN")
    saveRDS(pop.data, "popData.rds")
    rm(data.frag)
} else pop.data <- readRDS("popData.rds")
```

```{r}

    # BoxPlot tripDuration - Heavy Outliers!
boxplot(pop.data$tripduration)
    
    # How Many Greater than 24 hours?
print(nrow(pop.data[pop.data$tripduration>86400,]))

    # Remove > 24 Hours
pop.data <- pop.data[pop.data$tripduration<86400,c("tripduration", "DayOfWeek", "TimeOfDay")]

boxplot(pop.data$tripduration)

bwplot(tripduration ~ DayOfWeek, data = pop.data)
bwplot(tripduration ~ TimeOfDay | DayOfWeek, data = pop.data, scales=list(x=list(rot=45)))

trueMean <- mean(pop.data$tripduration)

print(paste0("The true mean of the population less outliers is: ", trueMean))

```

### Task 1
#### Stratified Sampling (Proportional Allocation)

First, we estimate the number of samples needed for a simple random sample(SRS) design. Although our goal is to perform a stratified sample for our estimate, we first need to compute a SRS design estimate to assist in calculation of design effect for the stratified design.

$n_{0,srs}=\frac{(Z_{\alpha/2}S)^2}{(moe)^2}=\frac{1.96^2 \times 1400.1478^2}{(15)^2}=33471.6752\approx33472$


Because the sample size is less than 10% of the original population, we may ignore the fpc adjustment performed in step 2, leaving us with a sample size of 33472.

```{r}
####Compute the sample size for a SRS
stdev = sd(pop.data$tripduration)
MOE   = 15 #seconds
N = nrow(pop.data)
print(stdev)
n0srs = ceiling((1.96^2*stdev^2)/(MOE^2))

print(paste0('With a sample size only ',round(n0srs/N*100,4), '% of the original population, we ignore fpc.'))

print(paste0('Sample Size needed for an estimate of the mean trip duration within 15 seconds, with 95% confidence, is ' , n0srs, '.'))

```

Compute Estimate using survey library with SRS and survey design of SRS 
```{r}
SrsMeanEstimate<-function(Seed, SampSize, printOutput= TRUE){
set.seed(Seed)

pop.data.SRSSampled = sample_n(pop.data,SampSize)

if(printOutput == TRUE){
  print(nrow(pop.data.SRSSampled))
  print(bwplot(tripduration ~ DayOfWeek, data = pop.data.SRSSampled))
  print(bwplot(tripduration ~ TimeOfDay | DayOfWeek, data = pop.data.SRSSampled, scales=list(x=list(rot=45))))
}

mydesign <- svydesign(id = ~1, data = pop.data.SRSSampled)

srsMean = svymean(~tripduration, design = mydesign)
srsSE = SE(srsMean)
srsCI = confint(srsMean)

rm(pop.data.SRSSampled)
rm(mydesign)

return(list(as.numeric(srsMean[1]),
            as.numeric(srsSE),
            as.numeric(srsCI[1]),
            as.numeric(srsCI[2])
           )
      )
}
```

```{r}
srsMean <- SrsMeanEstimate(n0srs, n0srs)
print(paste('The Mean Estimate =', srsMean[[1]]))
print(paste('The Standard Error =', srsMean[[2]]))
```

Compute Estimate using survey library with n<sub>0,srs</sub>, but use surveyDesign of Stratified Sample


```{r}
PropMeanEstimate<-function(Seed, SampSize, SampSizeAdj, printOutput= TRUE){

set.seed(Seed)

  # Identify Frequency of DayOfWeek Stratum
PropFreq <- as.data.frame(table(pop.data[,c("DayOfWeek", "TimeOfDay")]))
names(PropFreq)[1] = 'DayOfWeek'
PropFreq

PropFreq$N = nrow(pop.data)
PropFreq$p = PropFreq$Freq/PropFreq$N
PropFreq$SampSizeh = (PropFreq$p * SampSize)-SampSizeAdj  #adjustment of SampSizeAdj in order to round down the closest to .5 stratum due to an original rounded sample size 2 higher than n0srs
PropFreq$SampSizehRounded = round(PropFreq$SampSizeh)


pop.data.PropSampled <- NULL

for (i in 1:nrow(PropFreq)){
  pop.data.PropSampled<-rbind(pop.data.PropSampled,
                            sample_n(pop.data[(pop.data$DayOfWeek == PropFreq[i,"DayOfWeek"] 
                                                  & pop.data$TimeOfDay ==   PropFreq[i,"TimeOfDay"])
                                              ,]
                                     ,PropFreq[i,"SampSizehRounded"]
                                     )
                            )
                                
}

if(printOutput == TRUE){
  print(PropFreq)
  print(nrow(pop.data.PropSampled))
  print(bwplot(tripduration ~ DayOfWeek, data = pop.data.PropSampled))
  print(bwplot(tripduration ~ TimeOfDay | DayOfWeek, data = pop.data.PropSampled, scales=list(x=list(rot=45))))
}

mydesign <- svydesign(id = ~1, strata = ~paste(DayOfWeek,TimeOfDay), data = pop.data.PropSampled)

propMean = svymean(~tripduration, design = mydesign)
propSE = SE(propMean)
propCI = confint(propMean)

rm(pop.data.PropSampled)
rm(mydesign)
propCI = confint(propMean)
return(list(as.numeric(propMean[1]),
            as.numeric(propSE),
            as.numeric(propCI[1]),
            as.numeric(propCI[2])
           )
      )
}

```

```{r}
propMean <- PropMeanEstimate(n0srs, n0srs, .072)
print(paste('The Mean Estimate =', propMean[[1]]))
print(paste('The Standard Error =', propMean[[2]]))
```

Compute the Design Effect (SE stratified design / SE SRS Design)

$deff_{complex}=\frac{V(\bar{y}_{complex})}{V( \bar{y} {srs)})}=\frac{8.1176}{8.2137}=0.9883$

```{r}

deffProp = as.numeric(propMean[[2]]/srsMean[[2]])
deffProp

```

Compute appropriate Sample Size for Stratified Design Effect Modification (see 5.6 slides)
$n_{0,complex} = n_{0,srs} \times deff_{complex}= 33472 \times 0.9883 = 33080.25 \approx 33081$

```{r}
n0prop = n0srs*deffProp
n0prop
n0prop = ceiling(n0prop)
n0prop

```


Compute Proportional Allocation sample sizes amongst stratum
Utilize Sample Sizes to compute an Estimate of the mean, using Stratified Design with appropriate sample size

```{r}
propMean <- PropMeanEstimate(n0srs, n0prop, -.01)
print(paste('The Mean Estimate =', propMean[[1]]))
print(paste('The Standard Error =', propMean[[2]]))
```




#### Neyman Sampling Design

```{r}
  # Identify Frequency of DayOfWeek Stratum
NeyFreq <- as.data.frame(table(pop.data[,c("DayOfWeek", "TimeOfDay")]))
names(NeyFreq)[1] = 'DayOfWeek'

stdDevs <- tapply(pop.data$tripduration, paste(pop.data$TimeOfDay, pop.data$DayOfWeek), sd)
NhSh <- NeyFreq$Freq * stdDevs
NhSh.ratio <- NhSh/sum(NhSh)
sampsRaw <- round(n0srs)*NhSh.ratio
Neyman.samples <- round(sampsRaw)

#cbind(ToDFreq, stdDevs = as.data.frame(as.vector(stdDevs)), as.data.frame(NhSh), as.data.frame(NhSh.ratio), as.data.frame(sampsRaw), as.data.frame(Neyman.samples))
data.frame(NeyFreq,
           stdDevs = as.vector(stdDevs),
           NhSh = as.vector(NhSh),
           NhSh.ratio = as.vector(NhSh.ratio),
           sampsRaw = as.vector(sampsRaw),
           Neyman.samples = as.vector(Neyman.samples))
```
<br>
By rounding the calculated strata sample counts in our table output above, we now have definitive Neyman sample sizes for each stratum. To help validate these numbers' derivation, we choose to calculate their sum - their sum should calculate to our n<sub>0,srs</sub> value.
```{r}
paste("n0srs = ", n0srs)
paste("Neyman Samples Total = ", sum(Neyman.samples))
```
<br>
As observed above, our sum is just two samples larger than the n<sub>0,srs</sub> value. This is due to rounding error when deriving our whole number sample sizes from our raw, calculated sample sizes. Since our Neyman sample size is larger than the minimum calculated via n<sub>0,srs</sub>, no further action would normally be required; we are ensured our Neyman sample sizes will obtain for us an estimate with no more than 15 seconds MOE (with 95% confidence). However, because our intent is to also calculate Design Effect, it would be best to manually adjust our total sample count to match n<sub>0,srs</sub>.

When manually adjusting the sample count, we choose to find the two strata whose calculated sample size has the lowest decimal value over 0.5 and subtract one sample from their rounded sample counts. The two strata that meet this criterian are *Tuesday Evening* and *Sunday Afternoon*. Therefore, we lower their *Neyman.samples* by one.

```{r}
paste("Sunday Afternoon before change: ", Neyman.samples[4])
Neyman.samples[4] = Neyman.samples[4] - 1
paste("Sunday Afternoon after change: ", Neyman.samples[4])

paste("Tuesday Evening before change: ", Neyman.samples[13])
Neyman.samples[13] = Neyman.samples[13] - 1
paste("Tuesday Evening after change: ", Neyman.samples[13])

paste("Neyman Samples Total = ", sum(Neyman.samples))
```


```{r}
pop.data.Neyman <- data.frame(DayOfWeek = pop.data$DayOfWeek, TimeOfDay = pop.data$TimeOfDay, tripduration = pop.data$tripduration)
pop.data.Neyman$N <- NA

for(i in 1:nrow(NeyFreq)){
    pop.data.Neyman$N[paste(pop.data.Neyman$TimeOfDay, pop.data.Neyman$DayOfWeek) ==
                          attributes(Neyman.samples[i])] <- Neyman.samples[i]
}

head(pop.data.Neyman)
tail(pop.data.Neyman)
```

```{r}
set.seed(n0srs)
pop.data.NeySampled <- NULL

for (i in 1:nrow(NeyFreq)){
  pop.data.NeySampled<-rbind(pop.data.NeySampled,
                            sample_n(pop.data.Neyman[paste(pop.data.Neyman$TimeOfDay,
                                                           pop.data.Neyman$DayOfWeek) ==
                                                         attributes(Neyman.samples[i]),],
                                     Neyman.samples[i]))

}
```

```{r}
NeySamp <- merge(pop.data.NeySampled, NeyFreq, by = c("TimeOfDay","DayOfWeek"))
```


```{r}
  # Create SurveyDesign
mydesign <- svydesign(id = ~1, strata = ~paste(DayOfWeek,TimeOfDay), data = NeySamp) # Dropped since no correction needed: , fpc = ~Freq)

#mydesign <- postStratify(design = mydesign, strata = ~DayOfWeek, population = ToDFreq)

NeyMean <- svymean(~tripduration, design = mydesign)
NeyMean
```

$deff_{complex}=\frac{V(\bar{y}_{complex})}{V( \bar{y} {srs)})}=\frac{7.7424}{8.2137}=0.9426$

```{r}

deffNey = as.numeric(SE(NeyMean)/srsMean[[2]])
deffNey

```

Compute appropriate Sample Size for Neyman Design Effect Modification (see 5.6 slides)
$n_{0,complex} = n_{0,srs} \times deff_{complex}= 33474 \times 0.9426 = 31551.39 \approx 31552$

```{r}
n0Ney = n0srs*deffNey
n0Ney
n0Ney = ceiling(n0Ney)
n0Ney

```

Compute Neyman Allocation sample sizes amongst stratum
Utilize Sample Sizes to compute an Estimate of the mean, using Neyman Design with appropriate sample size

```{r}
sample.Neyman <- function(seed.value){
    set.seed(seed.value)
    
      # Identify Frequency of DayOfWeek and TimeOfDay Stratum
    NeyFreq <- as.data.frame(table(pop.data[,c("DayOfWeek", "TimeOfDay")]))
    names(NeyFreq)[1] = 'DayOfWeek'
    
    stdDevs <- tapply(pop.data$tripduration, paste(pop.data$TimeOfDay, pop.data$DayOfWeek), sd)
    NhSh <- NeyFreq$Freq * stdDevs
    NhSh.ratio <- NhSh/sum(NhSh)
    sampsRaw <- round(n0Ney)*NhSh.ratio
    Neyman.samples <- round(sampsRaw)
    
    return(list(data.frame(NeyFreq,
               stdDevs = as.vector(stdDevs),
               NhSh = as.vector(NhSh),
               NhSh.ratio = as.vector(NhSh.ratio),
               sampsRaw = as.vector(sampsRaw),
               Neyman.samples = as.vector(Neyman.samples)),
           NeyFreq, Neyman.samples))
}
```

```{r}
Neyman.survey <- function(NeymanSamps, seed.value, Freq, Neyman.samples){
    set.seed(seed.value)
    
    pop.data.Neyman <- data.frame(DayOfWeek = pop.data$DayOfWeek, TimeOfDay = pop.data$TimeOfDay,
                                  tripduration = pop.data$tripduration)
    pop.data.Neyman$N <- NA
    
    for(i in 1:nrow(Freq)){
    pop.data.Neyman$N[paste(pop.data.Neyman$TimeOfDay, pop.data.Neyman$DayOfWeek) ==
                          attributes(Neyman.samples[i])] <- Neyman.samples[i]
    }
    
    pop.data.NeySampled <- NULL
    
    for (i in 1:nrow(Freq)){
      pop.data.NeySampled<-rbind(pop.data.NeySampled,
                                sample_n(pop.data.Neyman[paste(pop.data.Neyman$TimeOfDay,
                                                               pop.data.Neyman$DayOfWeek) ==
                                                             attributes(Neyman.samples[i]),],
                                         Neyman.samples[i]))
    
    }
    
    NeySamp <- merge(pop.data.NeySampled, Freq, by = c("TimeOfDay","DayOfWeek"))
    
      # Create SurveyDesign
    mydesign <- svydesign(id = ~1, strata = ~paste(DayOfWeek,TimeOfDay), data = NeySamp)
    
    NeyMean <- svymean(~tripduration, design = mydesign)
    NeyMean
    
    NeyCI <- confint(svymean(~tripduration, design = mydesign))
    NeyCI
    
    #rm(pop.data.Neyman)
    #rm(mydesign)
    
    return(list(NeySamp, NeyMean, NeyCI))
}
```

```{r}
output <- sample.Neyman(n0srs)
NeymanSamps <- output[[1]]
NeyFreq <- output[[2]]
Neyman.samples <- output[[3]]

rm(output)
```

```{r}
Neyman.survey(NeymanSamps, n0srs, NeyFreq, Neyman.samples)
```


### Task 2 - Compare Confidence Intervals against 5 samples
#### Stratified Sampling (Proportional Allocation)
```{r}

SeedList <- c(10000, 20000, 30000, 40000, 50000)

df<- NULL

  #SRS Seed Executions
for (seed in SeedList){
  srsEstimate <- SrsMeanEstimate(seed, n0srs, FALSE)
  srsEstimate <- data.frame('SRS', seed, srsEstimate)
  names(srsEstimate) <- c("EstimateType","SeedValue", "MeanEstimate", "SE", "LCI", "UCI")
  df<- rbind(df,
             srsEstimate
            )
}

  #Prop Seed Executions
for (seed in SeedList){
  PropEstimate <- PropMeanEstimate(seed, n0prop, -.01, FALSE)
  PropEstimate <- data.frame('Prop', seed, PropEstimate)
  names(PropEstimate) <- c("EstimateType","SeedValue", "MeanEstimate", "SE", "LCI", "UCI")
  df<- rbind(df,
             PropEstimate
            )
}


#  #Ney Seed Executions
#for (seed in SeedList){
#  NeyEstimate <- ####INSERT FUNCTION CALL HERE 
#  NeyEstimate <- data.frame('Ney', seed, NeyEstimate)
#  names(NeyEstimate) <- c("EstimateType","SeedValue", "MeanEstimate", "SE", "LCI", "UCI")
#  df<- rbind(df,
#             NeyEstimate
#            )
#}

  #Add True Mean Value, in-line with estimates
df$TrueMeanValue <- trueMean

  #Add Bool Value for whether the Conf Limit contains the True Mean Value
df$WithinConfLimBool <- df$LCI <= df$TrueMeanValue & df$UCI >= df$TrueMeanValue

  #Print Results
print(df)


```
